
      ///                                                                 Page 1


    1             ///
    2             //
    3             // Conway's Life for the PDP-8.
    4             //
    5             // Algorithm adapted from Chapter 17 of 
    6             //   "Graphics Programming Black Book" By  Michael Abrash.
    7             // http://www.gamedev.net/page/resources/_/technical/
    8             //   graphics-programming-and-theory/graphics-programming-black-book-r1698
    9             // (See Listing 17.5)
   10             //
   11             // If the Switch Register is all 0's on startup,
   12             // a hard-coded "glider" test pattern is loaded into the grid.
   13             // Otherwise, the Switch Register value is used as a pseudo-random seed
   14             // to generate the starting pattern.
   15             ///
   16             //
   17             // Assembly-time Constants.
   18             //
   19             // Grid Size.
   20             //
   21             
   22             DECIMAL
   23             
   24             // Grid dimensions for emulator "Run PDP-8 Screen".
   25             //nmRows=15
   26             //nmCols=77
   27             //nmCels=1155
   28             // Grid dimensions for use with PDP-8 emulator debug memory display.
   29             
   30       0014  nmRows=12
   31       0010  nmCols=8
   32       0140  nmCels=96
   33             
   34             // Grid dimensions to maximize use of VT-100 terminal in 
   35             //   PDP-8/E Java Emulator http://www.vandermark.ch/pdp8/index.php
   36             //nmRows=22
   37             //nmCols=80
   38             //nmCels=1760 // 22 rows by 80 cols. Word per cell implies 14 pages of 128 words per page.
   39             //
   40             
   41       0011  nmColP1=nmCols+1
   42       0007  nmColM1=nmCols-1
   43       0137  nmCelM1=nmCels-1
   44             //
   45             // asci Character Codes.
   46             //
   47       0033  asciEsc=27 // Escape
   48       0040  asciSpace=32 // Space (Blank)
   49       0015  asciCR=13 // Carriage Return
   50       0012  asciLF=10 // Line Feed
   51             
   52             OCTAL
   53             
   54             //
   55       0100  incrNbrCount=0100 // Increment neighbor count in high half word.
   56       37777777700  decrNbrCount=-incrNbrCount // Decrement neighbor count in high half word.
   57             //

      ///                                                                 Page 2


   58             ///
   59             //
   60             // Page 0 is always directly-addressable.
   61             //
   62             // Auto-Index "Register" addresses.
   63             //
   64       0010  air0=10
   65       0011  air1=11
   66       0012  air2=12
   67       0013  air3=13
   68       0014  air4=14
   69       0015  air5=15
   70       0016  air6=16
   71       0017  air7=17
   72             //
   73             ///
   74             //
   75       0020  *0020
   76             //
   77             // Bit Masks.
   78             //
   79 00020 0017  mNbrCount, 0017 // Right 4 bits to store 0 thru 8 as Neighbor Count.
   80 00021 0020  mClOnLo, 0020 // Cell marked "on" in lo half (5th bit from right).
   81 00022 2000  mClOnHi, 2000 // Cell marked "on" in hi half.
   82 00023 5777  mClOffHi, 5777 // Clear "on" bit in hi half.
   83 00024 0077  mLoHalf, 0077 // Right 6 bits.
   84 00025 7700  mHiHalf, 7700 // Left 6 bits.
   85 00026 0017  mRandBits, 0017 // Right 4 bits for random # (0 to 15).
   86 00027 0007  mLoOctalDigit, 0007 // Right-most octal digit.
   87             //
   88             // Memory Constants.
   89             //
   90 00030 7777  cMinOne, -1
   91 00031 7776  cMinTwo, -2
   92 00032 7775  cMinThree, -3
   93 00033 0010  cnmCols, nmCols
   94 00034 0140  cnmCels, nmCels
   95             //
   96             // String and Character Constants.
   97             //
   98 00035 0035  szClrScreen, . // VT-100 Clear Screen.
   99 00036 0033    asciEsc;"[;"2;"J
      00037 0333
      00040 0262
      00041 0312
  100 00042 0000    0
  101 00043 0043  szCrsrHome, . // VT-100 Cursor Home.
  102 00044 0033    asciEsc;"[;"0;";;"0;"H
      00045 0333
      00046 0260
      00047 0273
      00050 0260
      00051 0310
  103 00052 0000    0
  104 00053 0053  szSeed, . // Random seed display message.
  105 00054 0240    " ;" ;"S;"e;"e;"d;":;" 
      00055 0240

      ///                                                                 Page 3


      00056 0323
      00057 0345
      00060 0345
      00061 0344
      00062 0272
      00063 0240
  106 00064 0000    0
  107 00065 0065  szGeneration, . // Generation display message.
  108 00066 0240    " ;" ;"G;"e;"n;"e;"r;"a;"t;"i;"o;"n;":;" 
      00067 0240
      00070 0307
      00071 0345
      00072 0356
      00073 0345
      00074 0362
      00075 0341
      00076 0364
      00077 0351
      00100 0357
      00101 0356
      00102 0272
      00103 0240
  109 00104 0000    0
  110 00105 0105  szNewLine, . // Carriage-Return/Line-Feed combination.
  111 00106 0015    asciCR;asciLF
      00107 0012
  112 00110 0000    0
  113 00111 0040  charSpace, asciSpace
  114 00112 0260  charZero, "0
  115 00113 0252  charStar, "*
  116             //
  117             // Neighbor Cell Offsets.
  118             //
  119 00114 0114  cellOffsets, . // Base address to load into auto-index register.
  120 00115 7767  coNW, -nmColP1
  121 00116 7770  coN, -nmCols
  122 00117 7771  coNE, -nmColM1
  123 00120 0001  coE, 1
  124 00121 0011  coSE, nmColP1
  125 00122 0010  coS, nmCols
  126 00123 0007  coSW, nmColM1
  127 00124 7777  coW, -1
  128 00125 0000  coSelf, 0 // Terminate loop.
  129             //
  130             // Array Pointers.
  131             //
  132 00126 2007  pNWWrapCell, NWWrapCell // Extra "northwest" wrap cell.
  133 00127 2007  pTopWrapRow, CellBuffer-1 // Preceding address for auto-indexing to top wrap row.
  134 00130 2017  pGridCells, CellBuffer+nmColM1 // Preceding address for actual cell grid 
  135               // (after top wrap row).
  136 00131 2157  pBotWrapRow, CellBuffer+nmCols+nmCelM1 // Preceding address for bottom wrap row 
  137               // (after top wrap row and grid).
  138 00132 2170  pSEWrapCell, CellBuffer+nmCols+nmCels+nmCols // Extra "southeast" wrap cell 
  139               // (after top wrap row, cell grid, and bottom wrap row.)
  140             //
  141 00133 2147  pNWPairCell, NWWrapCell+nmCels // Pair for "northwest" wrap cell 
  142               // (just before top pair row).

      ///                                                                 Page 4


  143 00134 2147  pTopPairRow, CellBuffer+nmCelM1 // Preceding address for pair for top wrap row 
  144               // (just after NW pair).
  145 00135 2017  pBotPairRow, CellBuffer+nmColM1 // Preceding address for pair for bottom wrap row 
  146               // (same as grid).
  147 00136 2030  pSEPairCell, CellBuffer+nmCols+nmCols // Pair for "southwest" wrap cell 
  148               // (just after bottom pair row).
  149             //
  150             // Subroutine Pointers.
  151             //
  152 00137 1200  SkipIfChar, srSkipIfChar
  153 00140 1206  GetChar, srGetChar
  154 00141 1213  PutChar, srPutChar
  155 00142 1221  PutString, srPutString
  156 00143 1230  PutNewLine, srPutNewLine
  157 00144 1235  PutOctal, srPutOctal
  158 00145 1302  SetRand, srSetRand
  159 00146 1305  GetRand, srGetRand
  160 00147 1320  EmuMUY, srEmuMUY
  161 00150 0405  ClrGeneration, srClGeneration
  162 00151 0400  LoadSeed, srLoadSeed
  163 00152 0413  ShowSeedAndGeneration, srShSeedAndGeneration
  164 00153 0433  ClrWrap, srClWrap
  165 00154 0454  ClrGrid, srClGrid
  166 00155 0535  RandomizeGrid, srRandomizeGrid
  167 00156 0467  InitGrid, srInitGrid
  168 00157 0600  ShowGrid, srShGrid
  169 00160 0644  ProcessGeneration, srProcessGeneration
  170 00161 1045  CloneGrid, srClnGrid
  171 00162 1066  CloneCell, srClnCell
  172 00163 0723  CellBorn, srCelBorn
  173 00164 0737  CellDied, srCelDied
  174 00165 0751  CellNeighbors, srCelNeighbors
  175 00166 1000  ProcWrap, srPrcWrap
  176             //
  177             // Global Variables.
  178             //
  179 00167 0000  gGeneration, 0
  180 00170 0000  gSeed, 0
  181             //
  182             ///
  183             //
  184             // Main Code Page.
  185             //
  186       0200  *0200
  187 00200 7300  Main, cla cll // Clear AC and Link.
  188 00201 6046    tls / Wake Up Printer (terminal display)
  189 00202 4551    jms i LoadSeed
  190 00203 4550    jms i ClrGeneration  
  191 00204 4552    jms i ShowSeedAndGeneration
  192 00205 4553    jms i ClrWrap
  193 00206 4554    jms i ClrGrid
  194 00207 4556    jms i InitGrid 
  195 00210 4561    jms i CloneGrid
  196 00211 4557    jms i ShowGrid
  197 00212 4537    jms i SkipIfChar
  198 00213 5215      jmp MainLoop
  199 00214 5222    jmp MainPause

      ///                                                                 Page 5


  200 00215 4560  MainLoop, jms i ProcessGeneration
  201 00216 4561    jms i CloneGrid
  202 00217 4557    jms i ShowGrid
  203 00220 4537    jms i SkipIfChar
  204 00221 5215      jmp MainLoop
  205 00222 7402  MainPause, hlt // Halt.
  206 00223 5215    jmp MainLoop // Resume loop if user continues via front-panel.
  207             
  208 00224 7300  End, cla cll // Clear AC and Link.
  209 00225 7402    hlt // Halt.
  210 00226 5200    jmp Main // Restart if user continues via front panel.
  211             //
  212             // Application Subroutines.
  213             //
  214       0400  *0400
  215             //
  216             // Subroutine: Load Seed from Switch Register.
  217             // Parameter: Switch Register.
  218             // Updates: Global value gSeed.
  219             //
  220 00400 0000  srLoadSeed, 0
  221 00401 7300    cla cll // Clear AC and Link.
  222 00402 7404    osr // Or the Switch Register bits into AC.
  223 00403 3170    dca gSeed // Save random seed.
  224 00404 5600    jmp i srLoadSeed // Return
  225             //
  226             // Subroutine: Clear Generation.
  227             // No parameter.
  228             // Updates: Global value gGeneration.
  229             //
  230 00405 0000  srClGeneration, 0
  231 00406 7300    cla cll
  232 00407 3167    dca gGeneration
  233 00410 1035    tad szClrScrn
  234 00411 4542    jms i PutString
  235 00412 5605    jmp i srClGeneration // Return
  236             //
  237             // Subroutine: Show Seed.
  238             // Global value: gSeed.
  239             // No parameter.
  240             //
  241 00413 0000  srShSeedAndGeneration, 0
  242 00414 7300    cla cll
  243 00415 1043    tad szCrsrHome
  244 00416 4542    jms i PutString
  245 00417 1053    tad szSeed
  246 00420 4542    jms i PutString
  247 00421 7300    cla cll
  248 00422 1170    tad gSeed
  249 00423 4544    jms i PutOctal 
  250 00424 1065    tad szGeneration
  251 00425 4542    jms i PutString
  252 00426 7300    cla cll
  253 00427 1167    tad gGeneration
  254 00430 4544    jms i PutOctal 
  255 00431 4543    jms i PutNewLine
  256 00432 5613    jmp i srShSeedAndGeneration // Return.

      ///                                                                 Page 6


  257             //
  258             // Subroutine: Clear Wrap rows and cells.
  259             // No parameter.
  260             // Registers: air1 air2
  261             //  
  262 00433 0000  srClWrap, 0
  263 00434 7300    cla cll
  264 00435 3526    dca i pNWWrapCell // Clear corner wrap cells.
  265 00436 3532    dca i pSEWrapCell
  266 00437 1033    tad cnmCols // Clear top and bottom wrap rows.
  267 00440 7041    cia // Negate.
  268 00441 3253    dca CWLpCount
  269 00442 1127    tad pTopWrapRow // Load address of top wrap row.
  270 00443 3011    dca air1 // Set 1st index register to loop thru top wrap row.
  271 00444 1131    tad pBotWrapRow // Load address of bottom wrap row.
  272 00445 3012    dca air2 // Set 2nd index register to loop thru bottom wrap row.
  273 00446 3411  CWWrapLoop, dca i air1 // Clear indirectly-indexed cells.
  274 00447 3412    dca i air2
  275 00450 2253    isz CWLpCount
  276 00451 5246      jmp CWWrapLoop // Non-zero counter, keep looping.
  277 00452 5633    jmp i srClWrap // Else, done looping so return.
  278 00453 0000  CWLpCount, 0 // Loop count.
  279             //
  280             // Subroutine: Clear Grid cells.
  281             // No parameter.
  282             // Registers: air0
  283             //
  284 00454 3266  srClGrid, dca CGLpCount
  285 00455 1034    tad cnmCels
  286 00456 7041    cia // Negate
  287 00457 3266    dca CGLpCount
  288 00460 1130    tad pGridCells // Load address of grid cells.
  289 00461 3010    dca air0 // Set index register to loop thru grid cell array.
  290 00462 3410  CGGridLoop, dca i air0 // Clear next grid cell.
  291 00463 2266    isz CGLpCount
  292 00464 5262      jmp CGGridLoop // Non-zero counter, keep looping.
  293 00465 5654    jmp i srClGrid // Else, done looping so return.
  294 00466 0000  CGLpCount, 0 // Loop count.
  295             //
  296             // Subroutine: Initialize Grid cells to a predetermined pattern.
  297             // No parameter.
  298             // Register: air0
  299             //
  300 00467 0000  srInitGrid, 0
  301 00470 7300    cla cll
  302 00471 1170    tad gSeed // Load random seed global value into AC.
  303 00472 7450    sna // Skip if non-zero AC.
  304 00473 5277      jmp IGFixedPattern // Else, zero means use fixed pattern.
  305 00474 4545    jms i SetRand // Set the value as the pseudo-random seed.
  306 00475 4555    jms i RandomizeGrid // Use the random pattern generator.
  307 00476 5667    jmp i srInitGrid // And return.  
  308 00477 1321  IGFixedPattern, tad szIGPattern // Load pattern preceding address.
  309 00500 3010    dca air0 // And save in auto-indexing register.
  310 00501 1033    tad cnmCols // Load # columns,
  311 00502 3310    dca IGMultiplier // And save as multiplier parameter.
  312 00503 1410  IGLoop, tad i air0 // Get next row offset (1-based).
  313 00504 7450    sna // Skip if non-zero.

      ///                                                                 Page 7


  314 00505 5315      jmp IGFinish // Else, finish up if AC = 0.
  315 00506 1030    tad cMinOne // Subtract 1 to make it 0-based.
  316 00507 4547    jms i EmuMUY // Multiply by column count.
  317 00510 0000  IGMultipler, 0 // Self-modified parameter value.
  318 00511 1410    tad i air0 // Add in column offset (1-based).
  319 00512 1130    tad pGridCells // Add in grid base preceding address.
  320 00513 4563    jms i CellBorn // Process new cell birth.
  321 00514 5303    jmp IGLoop // And loop to next cell pattern.
  322 00515 4566  IGFinish, jms i ProcWrap // Process wrap row neighbor counts.
  323 00516 4553    jms i ClrWrap // Clear wrap rows for next iteration.
  324 00517 5667    jmp i srInitGrid // Return.
  325 00520 0000  IGCurrAddr, 0
  326 00521 0521  szIGPattern, . // Null-terminated row/col offset list.
  327 00522 0001    1;2 // Glider
      00523 0002
  328 00524 0002    2;3
      00525 0003
  329 00526 0003    3;1;3;2;3;3
      00527 0001
      00530 0003
      00531 0002
      00532 0003
      00533 0003
  330 00534 0000    0 // Null-terminator.
  331             //
  332             // Subroutine: Randomize Grid cells.
  333             // No parameter.
  334             //
  335 00535 0000  srRandomizeGrid, 0
  336 00536 7300    cla cll
  337 00537 1130    tad pGridCells
  338 00540 3365    dca RGCurrCell
  339 00541 1130    tad pGridCells
  340 00542 1034    tad cnmCels  // Compute last cell pointer for grid.
  341 00543 3366    dca RGLastCell
  342 00544 4546  RGLoop, jms i GetRand // Get a random integer.
  343 00545 0026    and mRandBits  // Only keep 6 bits (0 to n-1).
  344 00546 7001    iac // Add 1 (1 to n).
  345 00547 1365    tad RGCurrCell  // Add random offset to cell pointer.
  346 00550 3365    dca RGCurrCell
  347 00551 1365    tad RGCurrCell // Reload and negate current cell pointer.
  348 00552 7041    cia
  349 00553 1366    tad RGLastCell // Subtract from last cell pointer.
  350 00554 7510    spa // Skip if AC >= 0
  351 00555 5362      jmp RGFinish // Else, finish up if negative.
  352 00556 7300    cla cll
  353 00557 1365    tad RGCurrCell // Load address of current cell into AC.
  354 00560 4563    jms i CellBorn // Process new cell birth.
  355 00561 5344    jmp RGLoop
  356 00562 4566  RGFinish, jms i ProcWrap // Process wrap row neighbor counts.
  357 00563 4553    jms i ClrWrap // Clear wrap rows for next iteration.
  358 00564 5735    jmp i srRandomizeGrid // Return.
  359 00565 0000  RGCurrCell, 0
  360 00566 0000  RGLastCell, 0
  361             //
  362       0600  *0600
  363             //

      ///                                                                 Page 8


  364             // Subroutine: Show Grid cells.
  365             // No parameter.
  366             // Registers: air0
  367             //
  368 00600 0000  srShGrid, 0
  369 00601 7300    cla cll
  370 00602 1130    tad pGridCells // Load address of grid array.
  371 00603 3010    dca air0 // Store pointer in auto-index register.
  372 00604 1033    tad cnmCols
  373 00605 7041    cia
  374 00606 3242    dca SGMColCount // Store minus rows per cell count.
  375 00607 1242    tad SGMColCount
  376 00610 3243    dca SGColCount // Copy to actual column cell loop counter.
  377 00611 1034    tad cnmCels
  378 00612 7041    cia
  379 00613 3241    dca SGLpCount // Store negative cell count.
  380 00614 7300  SGLoop, cla cll
  381 00615 1410    tad i air0 // Loop thru each grid cell.
  382 00616 0021    and mClOnLo // Mask just "on" bit in lo half (current state).
  383 00617 7440    sza // Skip if zero (treat as dead).
  384 00620 5223      jmp SGLive // Else treat as live.
  385 00621 1111  SGDead, tad charSpace
  386 00622 5225    jmp SGPutChar
  387 00623 7300  SGLive, cla cll
  388 00624 1113    tad charStar
  389 00625 4541  SGPutChar, jms i PutChar // Display space or star based on cell status.
  390 00626 2241    isz SGLpCount // See if we have processed all grid cells.
  391 00627 5232      jmp SGRowCheck // If not, check if we've reached the end of a row.
  392 00630 4543    jms i PutNewLine
  393 00631 5600    jmp i srShGrid // Return.
  394 00632 2243  SGRowCheck, isz SGColCount // Increment columns-per-row counter
  395 00633 5214      jmp SGLoop // Loop to next cell if non-zero.
  396 00634 4543    jms i PutNewLine
  397 00635 7300    cla cll
  398 00636 1242    tad SGMColCount // Reset col-per-row counter.
  399 00637 3243    dca SGColCount
  400 00640 5214    jmp SGLoop // Then loop to next cell.
  401 00641 0000  SGLpCount, 0 // Loop count.
  402 00642 0000  SGMColCount, 0
  403 00643 0000  SGColCount, 0
  404             //
  405             // Subroutine: Process Generation iteration.
  406             // No parameter.
  407             //
  408 00644 0000  srProcessGeneration, 0
  409 00645 2167    isz gGeneration // Increment generation # (Never will be zero, so will never skip.)
  410 00646 4552    jms i ShowSeedAndGeneration
  411 00647 7300    cla cll
  412 00650 1130    tad pGridCells
  413 00651 3320    dca PGCurrAddr // Initialize current cell address.
  414 00652 1034    tad cnmCels // Setup counter for processing each grid cell.
  415 00653 7041    cia // Negate.
  416 00654 3321    dca PGLpCount
  417 00655 2320  PGCellLoop, isz PGCurrAddr // Increment current grid cell address. (Will never skip.)
  418 00656 7300    cla cll
  419 00657 1720    tad i PGCurrAddr // Load cell state into AC.
  420 00660 7450    sna // Skip if AC non-zero.

      ///                                                                 Page 9


  421 00661 5313      jmp PGCheckLoop // Else, loop to next cell if current one is empty 
  422                   // (also means no neighbors).
  423 00662 0020    and mNbrCount // Mask to check living neighbor count.
  424 00663 3322    dca PGNbrCount // Save in local variable.
  425 00664 1720    tad i PGCurrAddr // Re-load current cell state.
  426 00665 0021    and mClOnLo // Mask to check only current state "live" bit.
  427 00666 7450    sna // Skip if AC non-zero (cell is "live").
  428 00667 5301      jmp PGIsDead // Else process "dead" cell.
  429 00670 7300  PGIsLive, cla cll
  430 00671 1322    tad PGNbrCount // Get neighbor count.
  431 00672 1031    tad cMinTwo // Subtract 2.
  432 00673 7510    spa // Skip if >= 0 (count >= 2).
  433 00674 5310      jmp PGDied // Else cell just died due to under-population.
  434 00675 1030    tad cMinOne // Subtract 1 (Now at original count - 3).
  435 00676 7540    sma sza // Skip if <= 0 (count <= 3).
  436 00677 5310      jmp PGDied // Else cell just died due to overcrowding.
  437 00700 5313    jmp PGCheckLoop // Otherwise, cell stays alive so process next cell.
  438 00701 1322  PGIsDead, tad PGNbrCount // Get neighbor count.  (AC was already zero).
  439 00702 1032    tad cMinThree // Subtract 3.
  440 00703 7440    sza // Skip if = 0 (count = 3).
  441 00704 5313      jmp PGCheckLoop // Else cell stays dead so process next cell.
  442 00705 1320  PGBorn, tad PGCurrAddr // Load address of current cell. (AC was already zero.)
  443 00706 4563    jms i CellBorn // Create new cell.
  444 00707 5313    jmp PGCheckLoop // Process next cell.
  445 00710 7300  PGDied, cla cll
  446 00711 1320    tad PGCurrAddr // Load address of current cell.
  447 00712 4564    jms i CellDied // Kill cell, then process next cell.
  448 00713 2321  PGCheckLoop, isz PGLpCount
  449 00714 5255      jmp PGCellLoop // Continue looping if non-zero. 
  450 00715 4566  PGFinish, jms i ProcWrap // Process wrapped neighbor counts.
  451 00716 4553    jms i ClrWrap // Clear wrapped counts for next iteration.  
  452 00717 5644    jmp i srProcessGeneration // Return
  453 00720 0000  PGCurrAddr, 0
  454 00721 0000  PGLpCount, 0 // Loop count.
  455 00722 0000  PGNbrCount, 0  
  456             //
  457             // Subroutine: Cell Born.
  458             // Parameter: AC contains address of cell.
  459             //
  460 00723 0000  srCelBorn, 0
  461 00724 3336    dca CBCellAddr
  462 00725 1736    tad i CBCellAddr // Load current cell state.
  463 00726 7421    mql // Move to MQ register and clear AC.
  464 00727 1022    tad mClOnHi // Load mask to turn on "live" bit in hi half word.
  465 00730 7501    mqa // "Or" in current cell state.
  466 00731 3736    dca i CBCellAddr // And store back in cell grid position.
  467 00732 1336    tad CBCellAddr // Reload grid cell address.
  468 00733 4565    jms i CellNeighbors // Increment cell neighbor counts
  469 00734 0100      incrNbrCount
  470 00735 5723    jmp i srCelBorn // Return when done.
  471 00736 0000  CBCellAddr, 0
  472             //
  473             // Subroutine: Cell Died.
  474             // Parameter: AC contains address of cell.
  475             //
  476 00737 0000  srCelDied, 0
  477 00740 3350    dca CDCellAddr

      ///                                                                Page 10


  478 00741 1750    tad i CDCellAddr // Load current cell state.
  479 00742 0023    and mClOffHi // Clear "live" bit in hi half word.
  480 00743 3750    dca i CDCellAddr // And store back in cell grid position.
  481 00744 1350    tad CDCellAddr // Reload grid cell address.
  482 00745 4565    jms i CellNeighbors // Increment cell neighbor counts
  483 00746 7700      decrNbrCount
  484 00747 5737    jmp i srCelDied // Return when done.
  485 00750 0000  CDCellAddr, 0
  486             //
  487             // Subroutine: Cell Neighbor count update.
  488             // Parameter: AC contains address of cell, 
  489             //            word after call contains increment or decrement constant.
  490             // Registers: air7
  491             //
  492 00751 0000  srCelNeighbors, 0
  493 00752 3371    dca CNCellAddr
  494 00753 1751    tad i srCelNeighbors // Load increment or decrement.
  495 00754 3373    dca CNIncrDecr
  496 00755 2351    isz srCelNeighbors // Prepare for skip-return.
  497 00756 1114    tad cellOffsets // Load index register with address before neighbor cell offsets list.
  498 00757 3017    dca air7
  499 00760 1417  CNLoop, tad i air7 // Load offset to a neighbor cell.
  500 00761 7450    sna // Skip if non-zero
  501 00762 5751      jmp i srCelNeighbors // Else, return if offset was zero.
  502 00763 1371    tad CNCellAddr // Load address of current cell.
  503 00764 3372    dca CNNbrAddr // And save as neighbor cell address.
  504 00765 1772    tad i CNNbrAddr // Load neighbor cell current state.
  505 00766 1373    tad CNIncrDecr // And increment or decrement that cell's neighbor count (hi half word).
  506 00767 3772    dca i CNNbrAddr // And store back to grid cell.
  507 00770 5360    jmp CNLoop
  508 00771 0000  CNCellAddr, 0
  509 00772 0000  CNNbrAddr, 0
  510 00773 0000  CNIncrDecr, 0
  511             //
  512       1000  *1000
  513             //
  514             // Subroutine: Process Wrap row and cell neighbor counts against intended cells.
  515             // No parameter.
  516             // Registers: air1 air2
  517             //  
  518 01000 0000  srPrcWrap, 0
  519 01001 7300    cla cll
  520 01002 1526    tad i pNWWrapCell // Load corner wrap cell.
  521 01003 0025    and mHiHalf // Mask to only keep hi half.
  522 01004 1533    tad i pNWPairCell // Add in grid pair cell state.
  523 01005 3533    dca i pNWPairCell // And save back to grid.
  524 01006 1532    tad i pSEWrapCell // Repeat for other corner wrap/pair.
  525 01007 0025    and mHiHalf
  526 01010 1536    tad i pSEPairCell
  527 01011 3536    dca i pSEPairCell
  528 01012 1127    tad pTopWrapRow // Load address of top wrap row.
  529 01013 3011    dca air1 // Set 1st index register to loop thru top wrap row.
  530 01014 1131    tad pBotWrapRow // Load address of bottom wrap row.
  531 01015 3012    dca air2 // Set 2nd index register to loop thru bottom wrap row.
  532 01016 1134    tad pTopPairRow // Load address of top pair row.
  533 01017 3243    dca PWTopAddr // Save in local variable.
  534 01020 1135    tad pBotPairRow // Load address of bottom pair row.

      ///                                                                Page 11


  535 01021 3244    dca PWBotAddr // Save in local variable.
  536 01022 1033    tad cnmCols // Setup counter for clearing top and bottom wrap rows.
  537 01023 7041    cia // Negate.
  538 01024 3242    dca PWLpCount
  539 01025 1411  PWWrapLoop, tad i air1 // Load wrapped top row neighbor count.
  540 01026 0025    and mHiHalf // Mask to only keep hi half.
  541 01027 2243    isz PWTopAddr // Increment top pair row cell address (will never skip).
  542 01030 1643    tad i PWTopAddr // Add in top pair row cell state
  543 01031 3643    dca i PWTopAddr // Store result back to grid cell.
  544 01032 1412    tad i air2 // Load wrapped bottom row neighbor count.
  545 01033 0025    and mHiHalf // Mask to only keep hi half.
  546 01034 2244    isz PWBotAddr // Increment bottom pair row cell address (will never skip).
  547 01035 1644    tad i PWBotAddr // Add in bottom pair row cell state.
  548 01036 3644    dca i PWBotAddr // Store result back to grid cell.
  549 01037 2242    isz PWLpCount // Increment loop counter.
  550 01040 5225      jmp PWWrapLoop // Non-zero counter, keep looping.
  551 01041 5600    jmp i srPrcWrap // Done looping, so return.
  552 01042 0000  PWLpCount, 0 // Loop count.
  553 01043 0000  PWTopAddr, 0
  554 01044 0000  PWBotAddr, 0
  555             //
  556             // Subroutine: Clone Grid Cells from prior iteration state to current.
  557             // Parameters: None.
  558             // Registers: air1, air2
  559             //
  560 01045 0000  srClnGrid, 0
  561 01046 7300    cla cll
  562 01047 1130    tad pGridCells // Load address of grid array.
  563 01050 3011    dca air1 // Store pointer in 1st auto-index register.
  564 01051 1011    tad air1 // Copy to 2nd index register.
  565 01052 3012    dca air2
  566 01053 1034    tad cnmCels
  567 01054 7041    cia
  568 01055 3265    dca CGCLpCount // Store negative cell count.
  569 01056 1411  CGCLoop, tad i air1 // Loop thru each grid cell.
  570 01057 7440    sza // Skip if zero.
  571 01060 4562      jms i CloneCell // Copy hi half (prior state) to lo half (current state).
  572 01061 3412    dca i air2 // Store cloned result back to grid cell.
  573 01062 2265    isz CGCLpCount // See if we have processed all grid cells.
  574 01063 5256      jmp CGCLoop // If not, keep looping.
  575 01064 5645    jmp i srClnGrid // Return.
  576 01065 0000  CGCLpCount, 0 // Loop count.
  577             //
  578             // Subroutine: Clone Cell State from prior iteration state to current.
  579             // Clone the left-half of the AC into the right-half.
  580             // Parameter: AC contains the cell contents to be cloned from 
  581             //            the left (hi) half to the right (lo) half.
  582             // Returns: Cloned result in AC.
  583             //
  584 01066 0000  srClnCell, 0
  585 01067 0025    and mHiHalf // Mask to keep only left-half of AC
  586 01070 7421    mql // Move AC to MQ and clear AC.
  587 01071 7501    mqa // Copy MQ back to AC.
  588 01072 7012    rtr // Rotate AC twice right.
  589 01073 7012    rtr // 2 more bits.
  590 01074 7012    rtr // Total of 6 bits rotation.
  591 01075 7501    mqa // OR in original high-half.

      ///                                                                Page 12


  592 01076 5666    jmp i srClnCell // Return.
  593             //
  594             // Utility Subroutines.
  595             //
  596       1200  *1200
  597             //
  598             // Subroutine: Skip If Character ready.
  599             // Check for keyboard character. 
  600             // Skip-return if present, returning the character in the AC. 
  601             // Else just return.
  602             // 
  603 01200 0000  srSkipIfChar, 0
  604 01201 6031    ksf // Is Keyboard Flag Raised?
  605 01202 5600      jmp i srSkipIfChar // No, just return.
  606 01203 6036    krb // Yes - Read Character to AC.
  607 01204 2200    isz srSkipIfChar // Increment return address.
  608 01205 5600    jmp i srSkipIfChar // Return to "skip" address.
  609             //
  610             // Read a keyboard character.  Wait until one appears.
  611             //
  612 01206 0000  srGetChar, 0
  613 01207 6031    ksf // Is Keyboard Flag Raised?
  614 01210 5207      jmp .-1 // No - Loop! (Wait Loop)
  615 01211 6036    krb // Yes - Read Character to AC.
  616 01212 5606    jmp i srGetChar // Return.
  617             //
  618             // Subroutine: Put Character to display.
  619             // Parameter: AC contains character.
  620             //
  621 01213 0000  srPutChar, 0
  622 01214 6041    tsf // Is Printer Ready?
  623 01215 5214      jmp .-1 // No - Loop! (Wait Loop)
  624 01216 6046    tls // Yes - Print the character!
  625 01217 7300    cla cll // Clear AC and Link
  626 01220 5613    jmp i srPutChar // Return
  627             //
  628             // Subroutine: Put String to terminal.
  629             // Display a null-terminated string.
  630             // Parameter: AC contains address of word preceding null-terminated string to display.
  631             // Registers: air6
  632             //
  633 01221 0000  srPutString, 0
  634 01222 3016    dca air6 // Deposit address of string to auto-index register.
  635 01223 1416    tad i air6 // Load character.
  636 01224 7450    sna // Is it a null? - skip if non-zero.
  637 01225 5621      jmp i srPutString / Yes - return if zero.
  638 01226 4213    jms srPutChar / No - display character (subroutines on same page).
  639 01227 5223    jmp .-4 / Get next character.
  640             //
  641             // Subroutine: Put New Line to terminal (Carriage-Return/Line-Feed combination).
  642             // Parameters: None.
  643             //
  644 01230 0000  srPutNewLine, 0
  645 01231 7300    cla cll
  646 01232 1105    tad szNewLine
  647 01233 4542    jms i PutString
  648 01234 5630    jmp i srPutNewLine

      ///                                                                Page 13


  649             //
  650             // Subroutine: Put Octal value to terminal.
  651             // Display a 4-digit octal value.
  652             // Parameter: AC contains the value to display.
  653             //
  654 01235 0000  srPutOctal, 0
  655 01236 7421    mql // Move AC to MQ and clear AC.
  656 01237 7501    mqa // Copy MQ back to AC.
  657 01240 0027    and mLoOctalDigit // Mask to keep only low octal digit.
  658 01241 1112    tad charZero // Convert to display digit.
  659 01242 3300    dca Octal0Digit
  660 01243 7501    mqa // Copy MQ to AC.
  661 01244 7012    rtr // Rotate right 2 bits.
  662 01245 7010    rar // Rotate right 1 bit.
  663 01246 7421    mql // Move AC to MQ and clear AC.
  664 01247 7501    mqa // Copy MQ back to AC.
  665 01250 0027    and mLoOctalDigit // Mask to keep only low octal digit.
  666 01251 1112    tad charZero // Convert to display digit.
  667 01252 3277    dca Octal1Digit
  668 01253 7501    mqa // Copy MQ to AC.
  669 01254 7012    rtr // Rotate right 2 bits.
  670 01255 7010    rar // Rotate right 1 bit.
  671 01256 7421    mql // Move AC to MQ and clear AC.
  672 01257 7501    mqa // Copy MQ back to AC.
  673 01260 0027    and mLoOctalDigit // Mask to keep only low octal digit.
  674 01261 1112    tad charZero // Convert to display digit.
  675 01262 3276    dca Octal2Digit
  676 01263 7501    mqa // Copy MQ to AC.
  677 01264 7012    rtr // Rotate right 2 bits.
  678 01265 7010    rar // Rotate right 1 bit.
  679 01266 0027    and mLoOctalDigit // Mask to keep only low octal digit.
  680 01267 1112    tad charZero // Convert to display digit.
  681 01270 3275    dca Octal3Digit
  682 01271 1274    tad OctalDigits
  683 01272 4542    jms i PutString
  684 01273 5635    jmp i srPutOctal // Return.
  685 01274 1274  OctalDigits, .  
  686 01275 0000  Octal3Digit, 0
  687 01276 0000  Octal2Digit, 0
  688 01277 0000  Octal1Digit, 0
  689 01300 0000  Octal0Digit, 0
  690 01301 0000  OctalNullTerminator, 0
  691             //
  692             //------------------------------------------------------------------------------
  693             //
  694             // The following srroutines are courtesy of:
  695             // https://www.grc.com/pdp-8/deepthought-sbc.htm
  696             //
  697             // Subroutine: Set Random number seed.
  698             // Parameter: AC contains seed value.
  699             //
  700 01302 0000  srSetRand, 0
  701 01303 3316    dca LastRand
  702 01304 5702    jmp i srSetRand // Return.
  703             //
  704             // Subroutine: Get Random number.
  705             //   This is the simplest way I know of to generate highly random

      ///                                                                Page 14


  706             //   looking 12-bit values.  It's a Linear Congruential Pseudo Random
  707             //   Number Generator (LCPRNG).  Each time it's called, it evaluates
  708             //   the expression:  NextRand = LastRand * 5545 + 541 (all octal)             
  709             // No parameters.
  710             // Returns: Random number in AC.
  711             //
  712 01305 0000  srGetRand,      0
  713 01306 7300                  CLA CLL
  714 01307 1316                  TAD     LastRand        // get the last PRNG value
  715 01310 4547                  JMS  I  EmuMUY          // multiply by the following constant:
  716 01311 5545                    5545                  // 2917 base 10 - LCPRNG multiplicand
  717 01312 1317                  TAD     cRandAdd        // sum in our LCPRNG addend
  718 01313 3316                  DCA     LastRand        // save this for next time
  719 01314 1360                  TAD     AccumHigh       // return the HIGH 12-bits as our result
  720 01315 5705                  JMP  I  srGetRand       // return the AC to the caller
  721             
  722 01316 0000  LastRand,       0                       // our previous random value
  723 01317 0541  cRandAdd,       541                     // 353 base 10
  724             //
  725             // Subroutine: Emulate Multiply instruction.
  726             //   This is a full 12x12 multiply, needed because the emulated PDP-8
  727             //   lacks the EAE "Extended Arithmetic Element" multiplier.
  728             // Parameters:
  729             //   AC contains Multiplier.
  730             //   The word after the call has Multiplicand.
  731             // Returns:
  732             //   Least significant 12-bits in AC.
  733             //   Most significant 12-bits in AccumHigh.
  734             //
  735 01320 0000  srEmuMUY,       0                      
  736 01321 3361                  DCA     Multiplier      // save the multiplier for shifting              
  737 01322 1355                  TAD     cMin12        // setup our -12 loop counter
  738 01323 3356                  DCA     PhaseCount
  739 01324 3357                  DCA     AccumLow        // clear our 24-bit results accumulator
  740 01325 3360                  DCA     AccumHigh       
  741             
  742 01326 1361  MultShift,      TAD     Multiplier      // get a bit from the multiplier
  743 01327 7104                  CLL RAL                 // move the high-bit into LINK
  744 01330 3361                  DCA     Multiplier      // put the updated multiplier back
  745 01331 7420                  SNL                     // we do need to add-in the multiplicand
  746 01332 5340                  JMP     MultIterate     // no multiplicand add-in
  747                             
  748 01333 1720                  TAD  I  srEmuMUY        // add the multiplicand into accumulator
  749 01334 1357                  TAD     AccumLow        // this *may* overflow, clearing the LINK
  750 01335 3357                  DCA     AccumLow        // either way, put the updated low 12 back
  751 01336 7420                  SNL                     // if LINK is still '1', no overflow
  752 01337 2360                  ISZ     AccumHigh       // bump the high-half if we carried out
  753                             
  754 01340 2356  MultIterate,    ISZ     PhaseCount      // see whether we've done all 12 bits
  755 01341 5346                  JMP     Shift24         // not done, so shift and iterate again
  756             
  757 01342 7300                  CLL CLA                 // return the lower 12-bits in AC
  758 01343 1357                  TAD     AccumLow
  759 01344 2320                  ISZ     srEmuMUY        // return to the instruction after multiplier
  760 01345 5720                  JMP  I  srEmuMUY
  761                             
  762 01346 1357  Shift24,        TAD     AccumLow        // get the lower 12-bit half

      ///                                                                Page 15


  763 01347 7104                  CLL RAL                 // shift it left, high bit into LINK
  764 01350 3357                  DCA     AccumLow        // put back the new low half
  765 01351 1360                  TAD     AccumHigh       // get the upper 12-bit half
  766 01352 7004                  RAL                     // shift it left, LINK into low bit
  767 01353 3360                  DCA     AccumHigh       // put back the new high half
  768 01354 5326                  JMP     MultShift
  769 01355 7764  cMin12,       7764
  770 01356 0000  PhaseCount,     0                       // our multiplier-shift counter
  771 01357 0000  AccumLow,       0                       // low 12-bits of 12x12 mult
  772 01360 0000  AccumHigh,      0                       // high 12-bits of 12x12 mult
  773 01361 0000  Multiplier,     0                       // temp used by multiplication
  774             //        
  775             //------------------------------------------------------------------------------
  776             //
  777             // Cell Array Pages.
  778             //
  779       2007  *2007 // Could be *2000, but *2007 aligns better in the PDP-8 emulator debug display.
  780 02007 0000  NWWrapCell, 0 // Extra "northwest" wrap cell.
  781 02010 0000  CellBuffer, 0 // Array of top wrap row, cell grid, bottom wrap row, and "southeast" wrap cell.  782             
  783             //
  784             ///

      No detected errors
